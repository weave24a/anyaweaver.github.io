<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Anya Weaver">

<title>Project Checkpoint 3: New Methodologies – Anya’s Website!</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Anya’s Website!</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About this site</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./STAT-244-SC.html"> 
<span class="menu-text">Test</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#project-checkpoint-3-new-methodologies" id="toc-project-checkpoint-3-new-methodologies" class="nav-link active" data-scroll-target="#project-checkpoint-3-new-methodologies">Project Checkpoint 3: New Methodologies</a>
  <ul class="collapse">
  <li><a href="#table-of-contents" id="toc-table-of-contents" class="nav-link" data-scroll-target="#table-of-contents">Table of Contents</a></li>
  <li><a href="#cross-validation-cv-required" id="toc-cross-validation-cv-required" class="nav-link" data-scroll-target="#cross-validation-cv-required">Cross Validation (CV) — <strong>Required</strong></a></li>
  <li><a href="#option-variable-subset-selection" id="toc-option-variable-subset-selection" class="nav-link" data-scroll-target="#option-variable-subset-selection">Option: Variable Subset Selection</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Project Checkpoint 3: New Methodologies</h1>
<p class="subtitle lead">STAT 244</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Anya Weaver </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="project-checkpoint-3-new-methodologies" class="level1">
<h1>Project Checkpoint 3: New Methodologies</h1>
<ul>
<li>Due date: Thursday, May 1st @ 11:59 pm (You may use a <a href="https://forms.gle/br6p6zY5ugi49LXV8">48 hour extension</a>)</li>
</ul>
<p>In this checkpoint, you’ll practice implementing the machine learning techniques you’ve been exposed to throughout this course.&nbsp;</p>
<p>Use the ideas and techniques we’ve discussed in class to best answer the following questions. Do your best to answer in complete, thoughtful, and concise sentences. The more work you do here, the less work you have to do for your final paper. My intent is that 100% of the content in your paper and presentation comes from these project checkpoints. These checkpoints are graded based on (perceived) genuine effort rather than correctness.&nbsp;</p>
<p>If you are working in a group, while your group will submit only <strong>one</strong> final paper, <strong>each person must submit an individual project checkpoint</strong> (even if the checkpoints are identical). I will provide feedback on one person’s project checkpoints per group.</p>
<p>Create a Quarto file to answer the following questions. Do not answer simply using a Google Doc. You are required to do the section on Cross Validation (CV). You may then choose any of the following sections after that.</p>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h2>
<p>Cross Validation (CV) — Required</p>
<p>Option: Variable Subset Selection</p>
<p>Option: LASSO</p>
<p>Option: Unsupervised Learning with K-Means Clustering</p>
</section>
<section id="cross-validation-cv-required" class="level2">
<h2 class="anchored" data-anchor-id="cross-validation-cv-required">Cross Validation (CV) — <strong>Required</strong></h2>
<p><strong>Resources:</strong></p>
<ul>
<li><p><a href="https://moodle.mtholyoke.edu/mod/assign/view.php?id=1098626">Lab 6: Intro to Model Evaluation</a></p></li>
<li><p><a href="https://moodle.mtholyoke.edu/mod/assign/view.php?id=1101117">Lab 7: k-Fold Cross Validation (CV)</a></p></li>
<li><p><a href="https://drive.google.com/file/d/1vuC24aYjC2CkOoVUDXd7O_8S_deGbf4H/view">Lab 7 Solutions</a></p></li>
<li><p><a href="https://docs.google.com/presentation/d/1yCWxHnb59LpRELyWgy2Ir1AD6j7SOtx9kvqkMN6drEc/edit?usp=sharing">Slides-Intro-CV-March10</a></p></li>
<li><p>Section 5.1 in <a href="https://moodle.mtholyoke.edu/mod/resource/view.php?id=1090837">ISLR</a></p></li>
</ul>
<ol type="1">
<li><p><strong>Write a brief introduction to cross validation which includes relevant mathematical notation.<br>
</strong>Cross validation is a method of training and testing statistical models for a dataset that does not come with a training data set. It is notated by the formula: E[Y|X] = β0 + β1X1+…+ βpXp, where Y is a random variable representing our outcome data, X is a random variable representing our input data, and E[Y|X] is the expected value of Y given input data X.<strong><br>
</strong></p></li>
<li><p><strong>What is the goal of cross-validation? (Hint: Think about over-fitting, along with <a href="https://moodle.mtholyoke.edu/mod/assign/view.php?id=1099679">social/ethical considerations</a>)&nbsp;<br>
</strong>The goal of cross-validation is to avoid overfitting, which is when a model constructed from a data set is so specific to that data that it cannot process any new data in the manner intended. This can cause problems if the training dataset has some bias, as it will reinforce that bias.</p></li>
<li><p><strong>What linear models are you considering based on your research question? Pick at least two models to compare.</strong></p>
<p>I am considering the three models:</p>
<p>E[Earnings_median_5yr | Debt_median] = β0+ β1(Debt_median)</p>
<p>E[Earnings_median_5yr | Earnings_median_1yr - Debt_median] = β0 - β1(Debt_median) + β2(Earnings_median_1yr)</p>
<p>E[Earnings_median_5yr | Earnings_median_1yr] = β0+ β1(Earnings_median_1yr)<strong><br>
</strong></p></li>
<li><p><strong>Explain how you divided your data into its test set and training set.<br>
<br>
</strong>I divided my data into its test set and training set using 10-Fold CV.<br>
</p></li>
<li><p><strong>State which error metric you are using (MAE or MSE) and give its formal mathematical definition. Why did you choose this error metric? What are the advantages/disadvantages of using it?<br>
<br>
I chose MAE because my dataset includes outliers, and MAE uses the difference between the number the model predicts and the actual value of the testing data set in order to calculate the mean error. The formal definition of MAE is</strong><img src="images/clipboard-1982362439.png" width="82" height="58"><br>
</p></li>
<li><p><strong>Implement k-fold cross validation for k = 10.</strong></p>
<p>Done</p></li>
<li><p><strong>Display evaluation metrics for your different models in a clean, organized way. This display should include both the estimated CV metric as well as its standard deviation.</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Model</th>
<th>10-Fold CV MAE</th>
<th>SD</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>7.663614e+03</td>
<td>231.69329447</td>
</tr>
<tr class="even">
<td>2</td>
<td>7.802707e+03</td>
<td>322.35471344</td>
</tr>
<tr class="odd">
<td>3</td>
<td>7.802707e+03</td>
<td>264.87574093</td>
</tr>
</tbody>
</table></li>
</ol>
<!-- -->
<ol start="8" type="1">
<li><p><strong>Try different values of k (the tuning parameter). At minimum, try k = n - 1 (LOOCV), and k = 5. Which value of k has the smallest CV error?<br>
<br>
</strong>k=5 has the smallest error<strong><br>
</strong></p></li>
<li><p><strong>Select your final model based on which one has the smallest CV error.</strong></p></li>
</ol>
<p>Model 1 with k = 10 has the smallest CV error.<br>
</p>
</section>
<section id="option-variable-subset-selection" class="level2">
<h2 class="anchored" data-anchor-id="option-variable-subset-selection">Option: Variable Subset Selection</h2>
<p><strong>Resources:</strong></p>
<ul>
<li><p><a href="https://docs.google.com/presentation/d/1j4wvhcj5qzvc2Qp4lpfVUJSjRpLAIm13mMqVyWQH88s/edit?usp=sharing">Slides-Subset-Selection</a></p></li>
<li><p><a href="https://moodle.mtholyoke.edu/mod/assign/view.php?id=1101596">Lab 8: Variable Subset Selection</a></p></li>
<li><p><a href="https://drive.google.com/file/d/10PIjBfVQxfRkkJFQG70QUyl1_iIJg40o/view?usp=sharing">Lab 8 Solutions</a></p></li>
<li><p>Section 6.1 in <a href="https://moodle.mtholyoke.edu/mod/resource/view.php?id=1090837">ISLR</a></p></li>
</ul>
<ol type="1">
<li><p><strong>Identify at least p = 3 predictors for modeling the expected response E(Y) of one of your variables Y.</strong><br>
<br>
Predictors: Major, School Type, Earnings_Median_1yr, Debt<br>
</p></li>
<li><p><strong>State which error metric you are using (i.e., CV MAE or CV MSE and state the chosen k-value).</strong><br>
<br>
CVMAE with k=10<br>
</p></li>
<li><p><strong>Best subset selection</strong>: Only implement this if you have under 100 rows/observations in your data set. Otherwise, skip this! It will be too computationally expensive!</p>
<p>I currently have 239 rows, so I skipped this.</p></li>
<li><p><strong>Backward subset selection: Implement backward subset selection by starting with at least p = 3 predictors.</strong></p>
<p>Done</p></li>
<li><p><strong>We have to pick a value for our tuning parameter (the number of predictors). Plot your cross validated error as a function of the number of predictors, where each model has predictors chosen based on your backward subset selection.</strong></p></li>
</ol>
<p>Could not figure out how to do this but, my model narrowed down until both Earnings_median_1yr and Debt were left, but both had the same p-value (0). Would have to try another type of variable subse4t to narrow down further, or keep both.<br>
</p>
<ol start="6" type="1">
<li><p><strong>Based on your plot, which model do you pick?<br>
<br>
</strong>Based on my plot, I should pick a model that uses both Earnings_median_1yr, and Debt.<strong><br>
</strong></p></li>
<li><p><strong>Why is backward subset selection a greedy algorithm? Answer in 1 - 3 sentences.<br>
<br>
</strong>Backward subset selection is a greedy algorithm because it takes out whichever variable changes the predicted value the most in each step.<br>
</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>